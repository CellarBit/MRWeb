<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Magic Ruler</title>
    <style>
     body {
            margin: 0;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
        }

        #controls button {
            display: block;
            margin: 5px;
            padding: 10px 20px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #controls button:hover {
            background-color: #0056b3;
        }

        #segment-info {
            margin-top: 10px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            color: #333;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="controls">
        <!-- <button id="focus-xy">Focus XY</button>
        <button id="focus-xz">Focus XZ</button> -->
        <button id="focus-yz">Focus YZ</button>
        <div id="segment-info">Select a segment to display its information.</div>
    </div>

    <!-- Local Three.js library -->
    <script src="js/three.min.js"></script>
    <!-- Local OrbitControls module -->
    <script src="js/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer;
        let controls;
        let ruler = [];
        let selectedSegment = null;

        // Initialize the scene
        function init() {
            // Scene
            scene = new THREE.Scene();

            // Initialize the camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Position the camera 
            camera.position.set(15, 0, 0); // Camera is 15 units away from the YZ plane along the X-axis
            camera.up.set(0, 0, 1); // vector to ensure alignment with the Y-axis
                     
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // Camera controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Create the axes helper
            const axesHelper = new THREE.AxesHelper(5); // Default size is 5 units
            scene.add(axesHelper);
            axesHelper.scale.y = 3; // Make the Y-axis longer Scale it by a factor.
            

            // Add button event listeners
            // document.getElementById('focus-xy').addEventListener('click', () => focusCamera('xy'));
            // document.getElementById('focus-xz').addEventListener('click', () => focusCamera('xz'));
            document.getElementById('focus-yz').addEventListener('click', () => focusCamera('yz'));

            // Add click event for segment selection
            renderer.domElement.addEventListener('click', onCanvasClick, false);

            // Create the ruler
            createRuler();

            // Start animation loop
            animate();
        }

        // Create the ruler with 24 segments
        function createRuler() {
            for (let n = 0; n < 24; n++) {
                let vertices, indices;

                if (n % 2 === 0) {
                    // Even n (including n = 0)
                    vertices = new Float32Array([
                        // Front face
                        0, n / 2, 0, // A
                        0, n / 2 + 1, 0, // B
                        0, n / 2 + 0.5, 0.5, // C

                        // Back face
                        1 / Math.sqrt(2), n / 2, 0, // A'
                        1 / Math.sqrt(2), n / 2 + 1, 0, // B'
                        1 / Math.sqrt(2),  n / 2 + 0.5, 0.5, // C'
                    ]);
                } else {
                    // Odd n
                    vertices = new Float32Array([
                        // Front face
                        0, 1 + (n / 2), 0.5, // A
                        0, (n / 2), 0.5, // B
                        0, 0.5 + (n / 2), 0, // C

                        // Back face
                        1 / Math.sqrt(2), 1 + (n / 2), 0.5, // A'
                        1 / Math.sqrt(2), (n / 2), 0.5, // B'
                        1 / Math.sqrt(2), 0.5 + (n / 2), 0, // C'
                    ]);
                }

                // Define the indices (faces)
                indices = [
                    // Front face
                    0, 1, 2,

                    // Back face
                    3, 4, 5,

                    // Connecting faces
                    0, 3, 1,
                    1, 3, 4,
                    1, 4, 2,
                    2, 4, 5,
                    2, 5, 0,
                    0, 5, 3,
                ];

                // Create the geometry
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                geometry.setIndex(indices);

                // Compute normals for lighting
                geometry.computeVertexNormals();

                // Create the segment material
                // const segmentMaterial = new THREE.MeshBasicMaterial({
                //     color: n % 2 === 0 ? 0xff0000 : 0xffffff, // Black: 0x000000, White: 0xffffff, Red: 0xff0000, Green: 0x00ff00, Blue: 0x0000ff, Yellow: 0xffff00, Cyan: 0x00ffff, Magenta: 0xff00ff, Gray: 0x808080, Orange: 0xffa500, Purple: 0x800080, Pink: 0xffc0cb, Brown: 0xa52a2a
                //     side: THREE.DoubleSide,
                // });

                // Make it as reainbow-------

                const rainbowColors = [
                0xff0000, // Red
                0xff7f00, // Orange
                0xffff00, // Yellow
                0x00ff00, // Green
                0x0000ff, // Blue
                0x4b0082, // Indigo
                0x9400d3, // Violet
                ];

                const segmentMaterial = new THREE.MeshBasicMaterial({
                    color: rainbowColors[n % rainbowColors.length], // Cycle through rainbow colors
                    side: THREE.DoubleSide,
                });
                // ---------------------------

                // Create the segment
                const segment = new THREE.Mesh(geometry, segmentMaterial);
                segment.userData.index = n; // Store the segment index for identification

                // Add black edges
                const edges = new THREE.EdgesGeometry(geometry);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
                const line = new THREE.LineSegments(edges, lineMaterial);
                segment.add(line);

                ruler.push(segment);
                scene.add(segment);
            }
        }

        // Focus the camera on the ruler in a specific plane
        function focusCamera(plane) {
            switch (plane) {
                // case 'xy':
                //     camera.position.set(10, 10, 30);
                //     camera.lookAt(0, 0, 0);
                //     break;
                // case 'xz':
                //     camera.position.set(10, 0, 30);
                //     camera.lookAt(0, 0, 0);
                //     break;
                case 'yz':
                    camera.position.set(15, 0, 0); // Camera is 15 units away from the YZ plane along the X-axis
                    camera.up.set(0, 0, 1); // vector to ensure alignment with the Y-axis
                    camera.lookAt(0, 0, 0);
                    break;
            }
            controls.update(); // Update the controls
        }

        // Handle canvas clicks to select segments

        function onCanvasClick(event) {
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.params.Line.threshold = 0.01; // Adjust the threshold for more precision
            raycaster.setFromCamera(mouse, camera);

            // Recursively check for intersections with child objects
            const intersects = raycaster.intersectObjects(ruler, true);

            if (intersects.length > 0) {
                // Sort intersections by distance
                intersects.sort((a, b) => a.distance - b.distance);

                // Find the parent segment (if the clicked object is a child, like the edges)
                let selected = intersects[0].object;
                while (selected.parent && selected.parent !== scene) {
                    selected = selected.parent;
                }

                // Deselect the previously selected segment
                if (selectedSegment) {
                    // Restore the original color
                    selectedSegment.material.color.set(selectedSegment.userData.originalColor);
                }
                // Display segment information
                displaySegmentInfo(selected);
                // Highlight the selected segment
                if (!selected.userData.originalColor) {
                    // Store the original color if not already stored
                    selected.userData.originalColor = selected.material.color.getHex();
                }
                selected.material.color.set(0x80ffff); // Set to white
                selectedSegment = selected;
            }
            
        }

        // Display the selected segment's information
        function displaySegmentInfo(segment) {
            const n = segment.userData.index;
            const positions = segment.geometry.attributes.position.array;

            // Function to format a number as a fraction if it's approximately 1/sqrt(2)
            function formatNumber(value) {
                const sqrt2 = Math.sqrt(2);
                const tolerance = 0.0001; // Tolerance for floating-point comparison
                if (Math.abs(value - 1 / sqrt2) < tolerance) {
                    return "1/âˆš2";
                }
                return value.toFixed(1); // Display other numbers with 4 decimal places
            }

            // Extract vertex coordinates and format them
            const A = `A: (${formatNumber(positions[0])}, ${formatNumber(positions[1])}, ${formatNumber(positions[2])})`;
            const B = `B: (${formatNumber(positions[3])}, ${formatNumber(positions[4])}, ${formatNumber(positions[5])})`;
            const C = `C: (${formatNumber(positions[6])}, ${formatNumber(positions[7])}, ${formatNumber(positions[8])})`;
            const A_prime = `A': (${formatNumber(positions[9])}, ${formatNumber(positions[10])}, ${formatNumber(positions[11])})`;
            const B_prime = `B': (${formatNumber(positions[12])}, ${formatNumber(positions[13])}, ${formatNumber(positions[14])})`;
            const C_prime = `C': (${formatNumber(positions[15])}, ${formatNumber(positions[16])}, ${formatNumber(positions[17])})`;

            // Format the information
            const info = `
                <strong>Segment N = ${n}</strong><br>
                ${A}<br>
                ${B}<br>
                ${C}<br>
                ${A_prime}<br>
                ${B_prime}<br>
                ${C_prime}
            `;

            // Update the info box
            document.getElementById('segment-info').innerHTML = info;
        }
    


        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Required for damping
            renderer.render(scene, camera);
        }

        // Start the app
        init();
    </script>
</body>
</html>