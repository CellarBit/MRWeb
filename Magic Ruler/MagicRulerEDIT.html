<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Magic Ruler</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <!-- Local Three.js library -->
    <script src="js/three.min.js"></script>
    <!-- Local OrbitControls module -->
    <script src="js/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer;
        let controls;
        let ruler = [];

        // Scene
        scene = new THREE.Scene();

        // Initialize the camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        // Position the camera 
        camera.position.set(15, 0, 0); // Camera is 15 units away from the YZ plane along the X-axis
        camera.up.set(0, 0, 1); // Ensures alignment with the Y-axis
        camera.lookAt(0, 0, 0);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);

        // Camera controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Create the axes helper
        const axesHelper = new THREE.AxesHelper(5); // Default size is 5 units
        scene.add(axesHelper);

        // Function to create a prism with given vertices and indices
        function createSegment(n) {
            let vertices;
            if (n % 2 === 0) {
                // Even n (including n = 0)
                vertices = new Float32Array([
                    // Front face
                    0, n / 2, 0, // A
                    0, n / 2 + 1, 0, // B
                    0, n / 2 + 0.5, 0.5, // C

                    // Back face
                    1 / Math.sqrt(2), n / 2, 0, // A'
                    1 / Math.sqrt(2), n / 2 + 1, 0, // B'
                    1 / Math.sqrt(2), n / 2 + 0.5, 0.5, // C'
                ]);
            } else {
                // Odd n
                vertices = new Float32Array([
                    // Front face
                    0, 1 + (n / 2), 0.5, // A
                    0, (n / 2), 0.5, // B
                    0, 0.5 + (n / 2), 0, // C

                    // Back face
                    1 / Math.sqrt(2), 1 + (n / 2), 0.5, // A'
                    1 / Math.sqrt(2), (n / 2), 0.5, // B'
                    1 / Math.sqrt(2), 0.5 + (n / 2), 0, // C'
                ]);
            }

            const indices = [
                // Front face
                0, 1, 2,

                // Back face
                3, 4, 5,

                // Connecting faces
                0, 3, 1,
                1, 3, 4,
                1, 4, 2,
                2, 4, 5,
                2, 5, 0,
                0, 5, 3,
            ];

            // Create the geometry
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setIndex(indices);

            // Compute normals for lighting
            geometry.computeVertexNormals();

            // Create the material
            const color = (n % 2 === 0) ? 0xff0000 : 0xffffff; 
            const segmentMaterial = new THREE.MeshBasicMaterial({
                color: color,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.3
            });

            // Create the mesh
            const segment = new THREE.Mesh(geometry, segmentMaterial);
            segment.userData.index = n; // Store the segment index for identification

            // Add black edges
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
            const line = new THREE.LineSegments(edges, lineMaterial);
            segment.add(line);

            ruler.push(segment);
            scene.add(segment);
        }

        // Loop to add segments for n from 0 to a specified maximum value
        const maxN = 10; // Set the maximum value of N
        for (let n = 0; n <= maxN; n++) {
            createSegment(n);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
