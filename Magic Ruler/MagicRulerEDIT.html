<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Magic Ruler</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
        }

        #controls button {
            display: block;
            margin: 5px;
            padding: 10px 20px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #controls button:hover {
            background-color: #0056b3;
        }

        #segment-info {
            margin-top: 10px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            color: #333;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="controls">
        <button id="focus-yz">Focus YZ</button>
        <div id="segment-info">Select a segment to display its information.</div>
    </div>

    <!-- Local Three.js library -->
    <script src="js/three.min.js"></script>
    <!-- Local OrbitControls module -->
    <script src="js/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer;
        let controls;
        let ruler = [];
        let selectedSegment = null;

        // Initialize the scene
        function init() {
            // Scene
            scene = new THREE.Scene();

            // Initialize the camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Position the camera 
            camera.position.set(15, 0, 0); // Camera is 15 units away from the YZ plane along the X-axis
            camera.up.set(0, 0, 1); // vector to ensure alignment with the Y-axis
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // Camera controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Create the axes helper
            const axesHelper = new THREE.AxesHelper(5); // Default size is 5 units
            scene.add(axesHelper);
            axesHelper.scale.y = 3; // Make the Y-axis longer Scale it by a factor.

            // Add button event listeners
            document.getElementById('focus-yz').addEventListener('click', () => focusCamera('yz'));

            // Add click event for segment selection
            renderer.domElement.addEventListener('click', onCanvasClick, false);

            // Create the ruler
            createRuler();

            // Start animation loop
            animate();
        }

        // Create the ruler with 24 segments
        function createRuler() {
            for (let n = 0; n < 24; n++) {
                let vertices, indices;

                if (n % 2 === 0) {
                    // Even n (including n = 0)
                    vertices = new Float32Array([
                        // Front face
                        0, n / 2, 0, // A
                        0, n / 2 + 1, 0, // B
                        0, n / 2 + 0.5, 0.5, // C

                        // Back face
                        1 / Math.sqrt(2), n / 2, 0, // A'
                        1 / Math.sqrt(2), n / 2 + 1, 0, // B'
                        1 / Math.sqrt(2), n / 2 + 0.5, 0.5, // C'
                    ]);
                } else {
                    // Odd n
                    vertices = new Float32Array([
                        // Front face
                        0, 1 + (n / 2), 0.5, // A
                        0, (n / 2), 0.5, // B
                        0, 0.5 + (n / 2), 0, // C

                        // Back face
                        1 / Math.sqrt(2), 1 + (n / 2), 0.5, // A'
                        1 / Math.sqrt(2), (n / 2), 0.5, // B'
                        1 / Math.sqrt(2), 0.5 + (n / 2), 0, // C'
                    ]);
                }

                // Define the indices (faces)
                indices = [
                    // Front face
                    0, 1, 2,

                    // Back face
                    3, 4, 5,

                    // Connecting faces
                    0, 3, 1,
                    1, 3, 4,
                    1, 4, 2,
                    2, 4, 5,
                    2, 5, 0,
                    0, 5, 3,
                ];

                // Create the geometry
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                geometry.setIndex(indices);

                // Compute normals for lighting
                geometry.computeVertexNormals();

                // Create the segment material
                const segmentMaterial = new THREE.MeshBasicMaterial({
                    color: n % 2 === 0 ? 0xff0000 : 0xffff00, // Colors
                    side: THREE.DoubleSide,
                });

                // Create the segment
                const segment = new THREE.Mesh(geometry, segmentMaterial);
                segment.userData.index = n; // Store the segment index for identification

                // Add black edges
                const edges = new THREE.EdgesGeometry(geometry);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
                const line = new THREE.LineSegments(edges, lineMaterial);
                segment.add(line);

                ruler.push(segment);
                scene.add(segment);
            }
        }

        // Focus the camera on the ruler in a specific plane
        function focusCamera(plane) {
            camera.position.set(15, 0, 0); // Camera is 15 units away from the YZ plane along the X-axis
            camera.up.set(0, 0, 1); // vector to ensure alignment with the Y-axis
            camera.lookAt(0, 0, 0);

            controls.update(); // Update the controls
        }

        // Handle canvas clicks to select segments
        function onCanvasClick(event) {
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.params.Line.threshold = 0.01; // Adjust the threshold for more precision
            raycaster.setFromCamera(mouse, camera);

            // Recursively check for intersections with child objects
            const intersects = raycaster.intersectObjects(ruler, true);

            if (intersects.length > 0) {
                // Sort intersections by distance
                intersects.sort((a, b) => a.distance - b.distance);

                // Find the parent segment (if the clicked object is a child, like the edges)
                let selected = intersects[0].object;
                while (selected.parent && selected.parent !== scene) {
                    selected = selected.parent;
                }

                // Deselect the previously selected segment
                if (selectedSegment) {
                    // Restore the original color
                    selectedSegment.material.color.set(selectedSegment.userData.originalColor);
                }

                // Highlight the selected segment
                if (!selected.userData.originalColor) {
                    // Store the original color if not already stored
                    selected.userData.originalColor = selected.material.color.getHex();
                }
                selected.material.color.set(0x80ffff); // Set to highlight color
                selectedSegment = selected;

                // Display segment information
                displaySegmentInfo(selected);
            }
        }

  
// Display the selected segment's information
function displaySegmentInfo(segment) {
    const n = segment.userData.index;
    const positions = segment.geometry.attributes.position.array;

    // Function to format a number as a fraction if it's approximately 1/sqrt(2)
    function formatNumber(value) {
        const sqrt2 = Math.sqrt(2);
        const tolerance = 0.0001; // Tolerance for floating-point comparison
        if (Math.abs(value - 1 / sqrt2) < tolerance) {
            return "1/âˆš2";
        }
        return value.toFixed(1); // Display other numbers with 4 decimal places
    }

    // Extract vertex coordinates and format them
    const A = `A: (${formatNumber(positions[0])}, ${formatNumber(positions[1])}, ${formatNumber(positions[2])})`;
    const B = `B: (${formatNumber(positions[3])}, ${formatNumber(positions[4])}, ${formatNumber(positions[5])})`;
    const C = `C: (${formatNumber(positions[6])}, ${formatNumber(positions[7])}, ${formatNumber(positions[8])})`;
    const A_prime = `A': (${formatNumber(positions[9])}, ${formatNumber(positions[10])}, ${formatNumber(positions[11])})`;
    const B_prime = `B': (${formatNumber(positions[12])}, ${formatNumber(positions[13])}, ${formatNumber(positions[14])})`;
    const C_prime = `C': (${formatNumber(positions[15])}, ${formatNumber(positions[16])}, ${formatNumber(positions[17])})`;

    // Format the information
    const info = `
        <strong>Segment N = ${n}</strong><br>
        ${A}<br>
        ${B}<br>
        ${C}<br>
        ${A_prime}<br>
        ${B_prime}<br>
        ${C_prime}
    `;

    // Update the info box
    document.getElementById('segment-info').innerHTML = info;
}
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Required for damping
            renderer.render(scene, camera);
        }

        function rotateSegment(segment, rotationStep) {
    const n = segment.userData.index;
    const midpoint = getMidpoint(n);
    const axis = getFaceNormal(segment.geometry.attributes.position.array, [0, 1, 2]); // Use the first face to calculate the normal

    // Calculate the rotation angle (90 degrees per step)
    const angle = (Math.PI / 2) * rotationStep;

    // Rotate the segment around its midpoint
    rotateAroundPoint(segment, midpoint, axis, angle);

    // Update subsequent segments
    updateSubsequentSegments(n);
}
function rotateAroundPoint(object, point, axis, angle) {
    // Translate the object to the origin
    object.position.sub(point);

    // Rotate the object's position
    object.position.applyAxisAngle(axis, angle);

    // Rotate the object's orientation
    object.quaternion.setFromAxisAngle(axis, angle);

    // Translate the object back to its original position
    object.position.add(point);
}
function updateSubsequentSegments(n) {
    let currentSegment = ruler[n];
    for (let i = n + 1; i < ruler.length; i++) {
        const nextSegment = ruler[i];

        // Calculate the new position of the next segment
        const offset = segmentOffset.clone().applyQuaternion(currentSegment.quaternion);
        nextSegment.position.copy(currentSegment.position).add(offset);

        // Update the orientation of the next segment to match the current segment
        nextSegment.quaternion.copy(currentSegment.quaternion);

        // Move to the next segment
        currentSegment = nextSegment;
    }
}

function getMidpoint(n) {
    return new THREE.Vector3(1 / (2 * Math.sqrt(2)), 0.75 + n / 2, 0.5);
}

function getFaceNormal(vertices, faceIndices) {
    const v1 = new THREE.Vector3(vertices[faceIndices[0] * 3], vertices[faceIndices[0] * 3 + 1], vertices[faceIndices[0] * 3 + 2]);
    const v2 = new THREE.Vector3(vertices[faceIndices[1] * 3], vertices[faceIndices[1] * 3 + 1], vertices[faceIndices[1] * 3 + 2]);
    const v3 = new THREE.Vector3(vertices[faceIndices[2] * 3], vertices[faceIndices[2] * 3 + 1], vertices[faceIndices[2] * 3 + 2]);

    const edge1 = v2.clone().sub(v1);
    const edge2 = v3.clone().sub(v1);
    const normal = edge1.cross(edge2).normalize();

    return normal;
}

function onCanvasClick(event) {
    const mouse = new THREE.Vector2();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    const raycaster = new THREE.Raycaster();
    raycaster.params.Line.threshold = 0.01;
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(ruler, true);

    if (intersects.length > 0) {
        let selected = intersects[0].object;
        while (selected.parent && selected.parent !== scene) {
            selected = selected.parent;
        }

        if (selectedSegment) {
            selectedSegment.material.color.set(selectedSegment.userData.originalColor);
        }

        if (!selected.userData.originalColor) {
            selected.userData.originalColor = selected.material.color.getHex();
        }
        selected.material.color.set(0x80ffff); // Set to highlight color
        selectedSegment = selected;

        // Increment the rotation step
        const rotationStep = (selected.userData.rotationStep || 0) + 1;
        selected.userData.rotationStep = rotationStep;

        // Rotate the selected segment and update subsequent segments
        rotateSegment(selected, rotationStep);

        // Display segment information
        displaySegmentInfo(selected);
    }
}
const segmentOffset = new THREE.Vector3(0, 1, 0); // Each segment is 1 unit apart along the Y-axis

        // Start the app
        init();
    </script>
</body>
</html>